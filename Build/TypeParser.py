##----------------------------------------------------------------------------------------------------------------------
## TypeParser.py
##
## Copyright (C) 2010 WhiteMoon Dreams, Inc.
## All Rights Reserved
##----------------------------------------------------------------------------------------------------------------------

import os
import sys
import re
import stat
import string
import datetime

def PrintCommandLineUsage():
    print( 'Usage:', os.path.basename( sys.argv[ 0 ] ), 'includePath sourcePath [moduleApiPrefix]', file = sys.stderr )
    print( '    includePath      Base path of the "Include" file directory', file = sys.stderr )
    print( '    sourcePath       Base path of the "Source" file directory', file = sys.stderr )
    print( '    moduleApiPrefix  Prefix for module API preprocessor tokens', file = sys.stderr )
    print( '                     (default: "LUNAR_"', file = sys.stderr )

def ModuleToTokenName( moduleName ):
    lastCharacter = None
    wasLastCharacterUpper = False
    wasLastCharacterDot = False
    tokenName = ''
    for rawCharacter in moduleName:
        character = rawCharacter.upper()
        isCharacterUpper = ( character == rawCharacter )
        if wasLastCharacterDot or (not isCharacterUpper and wasLastCharacterUpper and tokenName != ''):
            tokenName += '_'

        if lastCharacter is not None:
            tokenName += lastCharacter

        lastCharacter = character
        wasLastCharacterUpper = isCharacterUpper
        wasLastCharacterDot = (lastCharacter == '.')
        if wasLastCharacterDot:
            lastCharacter = None

    if lastCharacter is not None:
        tokenName += lastCharacter

    return tokenName

argc = len( sys.argv )
if argc < 3:
    PrintCommandLineUsage()
    sys.exit( 2 )

# Get the source and include paths from the command line, as well as the (optional) API token prefix.
includePath = sys.argv[ 1 ]
sourcePath = sys.argv[ 2 ]

apiTokenPrefix = 'LUNAR_'
if argc > 3:
    apiTokenPrefix = sys.argv[ 3 ]

# Parse each module in the include path.
try:
    includeDirListing = os.listdir( includePath )
except:
    print( '[E] Error reading the contents of "', includePath, '": ', sys.exc_info()[ 1 ], sep = '', file = sys.stderr )
    sys.exit( 1 )

typeScopeRegExp = re.compile( r'\b(namespace|class\s+\w+_API|class)\s+(\w+)\b' )
objectDeclRegExp = re.compile( r'\b(?<!#define )L_DECLARE_OBJECT\(\s*\w+\s*,\s*[\w:]+\s*\)' )

sourceFormatString0 = \
'''//----------------------------------------------------------------------------------------------------------------------
// {FILE}
//
// Copyright (C) {YEAR} WhiteMoon Dreams, Inc.
// All Rights Reserved
//----------------------------------------------------------------------------------------------------------------------

// !!! AUTOGENERATED FILE - DO NOT EDIT !!!

#include "{MODULE}Pch.h"
#include "Platform/Assert.h"
#include "Engine/Package.h"

'''

includeListingFormatString = \
'''#include "{INCLUDE}"
'''

sourceFormatString1 = \
'''
static Lunar::StrongPtr< Lunar::Package > sp{MODULE}TypePackage;

{API_TOKEN_PREFIX}{MODULE_TOKEN}_API Lunar::Package* Get{MODULE}TypePackage()
{{
    Lunar::Package* pPackage = sp{MODULE}TypePackage;
    if( !pPackage )
    {{
'''

sourceFormatString2Engine = \
'''        HELIUM_VERIFY( Lunar::GameObject::InitStaticType() );

        Lunar::GameObject* pTypesPackageObject = Lunar::GameObject::FindChildOf( NULL, Lunar::Name( TXT( "Types" ) ) );
        HELIUM_ASSERT( pTypesPackageObject );
        HELIUM_ASSERT( pTypesPackageObject->IsPackage() );

        Lunar::GameObject* pPackageObject = Lunar::GameObject::FindChildOf(
            pTypesPackageObject,
            Lunar::Name( TXT( "{MODULE}" ) ) );
        HELIUM_ASSERT( pPackageObject );
        HELIUM_ASSERT( pPackageObject->IsPackage() );

        pPackage = Lunar::StaticCast< Lunar::Package >( pPackageObject );
        sp{MODULE}TypePackage = pPackage;
'''

sourceFormatString2Default = \
'''        Lunar::GameObject* pTypesPackageObject = Lunar::GameObject::FindChildOf( NULL, Lunar::Name( TXT( "Types" ) ) );
        HELIUM_ASSERT( pTypesPackageObject );
        HELIUM_ASSERT( pTypesPackageObject->IsPackage() );

        HELIUM_VERIFY( Lunar::GameObject::Create< Lunar::Package >(
            sp{MODULE}TypePackage,
            Lunar::Name( TXT( "{MODULE}" ) ),
            pTypesPackageObject ) );
        pPackage = sp{MODULE}TypePackage;
        HELIUM_ASSERT( pPackage );
'''

sourceFormatString3 = \
'''    }}

    return pPackage;
}}

{API_TOKEN_PREFIX}{MODULE_TOKEN}_API void Release{MODULE}TypePackage()
{{
    sp{MODULE}TypePackage = NULL;
}}

{API_TOKEN_PREFIX}{MODULE_TOKEN}_API void Register{MODULE}Types()
{{
    HELIUM_VERIFY( Get{MODULE}TypePackage() );

'''

typeRegLineFormatString = \
'''    HELIUM_VERIFY( {CLASS_PATH}::InitStaticType() );
'''

sourceFormatString4 = \
'''}}

{API_TOKEN_PREFIX}{MODULE_TOKEN}_API void Unregister{MODULE}Types()
{{
'''

typeUnregLineFormatString = \
'''    {CLASS_PATH}::ReleaseStaticType();
'''

sourceFormatString5 = \
'''
    Release{MODULE}TypePackage();
}}
'''

currentYear = datetime.datetime.now().year

for module in includeDirListing:
    # Skip the "Core" module.
    if module == 'Core':
        print( '[I] Skipping module "Core"...' )
        print()
        continue

    modulePath = os.path.join( includePath, module )

    # Skip non-directories.
    pathStat = os.stat( modulePath )
    if not stat.S_ISDIR( pathStat.st_mode ):
        continue

    # Parse each include file in the current module for GameObject-based class declarations.
    print( '[I] Processing module "', module, '"', sep = '' )
    try:
        moduleDirListing = os.listdir( modulePath )
    except:
        print(
            '[E] Error reading the contents of "', modulePath, '": ', sys.exc_info()[ 1 ],
            sep = '',
            file = sys.stderr )
        print()
        continue

    includeFiles = set()
    classPathNames = []

    for entry in moduleDirListing:
        # Only parse ".h" files.
        if os.path.splitext( entry )[ 1 ] != '.h':
            continue

        entryPath = os.path.join( modulePath, entry )

        # Skip directories (as if there should be a directory with a ".h" extension, but just in case...).
        pathStat = os.stat( entryPath )
        if stat.S_ISDIR( pathStat.st_mode ):
            continue

        # Parse the current file line-by-line.
        print( '[I] Parsing "', entryPath, '"', sep = '' )

        try:
            entryFile = open( entryPath, 'rt' )
        except:
            print(
                '[E] Error opening "', entryPath, '" for reading: ', sys.exc_info()[ 1 ],
                sep = '',
                file = sys.stderr )
            continue

        entryLines = entryFile.readlines()
        entryFile.close()

        scopeNames = []
        braceLevels = []
        currentBraceLevel = 0
        bInComment = False

        for entryLine in entryLines:
            # Strip out comment blocks.
            stripStartIndex = 0
            while stripStartIndex < len( entryLine ):
                if bInComment:
                    commentEndIndex = entryLine.find( '*/', stripStartIndex )
                    if commentEndIndex == -1:
                        entryLine = entryLine[ : stripStartIndex ]
                        break

                    bInComment = False
                    entryLine = entryLine[ : stripStartIndex ] + entryLine[ commentEndIndex + 2 : ]
                    continue

                searchEndIndex = len( entryLine )
                commentStartIndex = entryLine.find( '//', stripStartIndex, searchEndIndex )
                if commentStartIndex != -1:
                    searchEndIndex = commentStartIndex

                blockCommentStartIndex = entryLine.find( '/*', stripStartIndex, searchEndIndex )
                if blockCommentStartIndex != -1:
                    bInComment = True
                    stripStartIndex = blockCommentStartIndex
                    entryLine = entryLine[ : stripStartIndex ] + entryLine[ stripStartIndex + 2 : ]
                    continue

                if commentStartIndex != -1:
                    entryLine = entryLine[ : commentStartIndex ]

                break

            # Parse the current line for namespace declarations, class declarations, braces, and L_DECLARE_OBJECT()
            # macro calls.
            while entryLine != '':
                searchEndIndex = len( entryLine )
                typeScopeResult = typeScopeRegExp.search( entryLine )
                if typeScopeResult != None:
                    searchEndIndex = typeScopeResult.start()

                objectDeclResult = objectDeclRegExp.search( entryLine )
                if objectDeclResult != None:
                    objectDeclResultStart = objectDeclResult.start()
                    if objectDeclResultStart < searchEndIndex:
                        searchEndIndex = objectDeclResultStart
                    else:
                        objectDeclResult = None

                startBraceIndex = entryLine.find( '{', 0, searchEndIndex )
                if startBraceIndex != -1:
                    searchEndIndex = startBraceIndex

                endBraceIndex = entryLine.find( '}', 0, searchEndIndex )

                stripEndIndex = 0
                if endBraceIndex != -1:
                    if currentBraceLevel != 0:
                        currentBraceLevel -= 1
                        if len( braceLevels ) != 0 and braceLevels[ -1 ] >= currentBraceLevel:
                            del scopeNames[ -1 ]
                            del braceLevels[ -1 ]

                    stripEndIndex = endBraceIndex + 1
                elif startBraceIndex != -1:
                    currentBraceLevel += 1
                    stripEndIndex = startBraceIndex + 1
                elif objectDeclResult != None:
                    classPath = '::'.join( scopeNames )
                    if classPath != None and classPath != '':
                        classPathNames += [ classPath ]
                        includeFiles.add( module + '/' + entry )

                    stripEndIndex = objectDeclResult.end()
                elif typeScopeResult != None:
                    typeScope = typeScopeResult.group( 2 )
                    if len( braceLevels ) != 0 and braceLevels[ -1 ] == currentBraceLevel:
                        scopeNames[ -1 ] = typeScope
                    else:
                        scopeNames += [ typeScope ]
                        braceLevels += [ currentBraceLevel ]

                    stripEndIndex = typeScopeResult.end()
                else:
                    break

                entryLine = entryLine[ stripEndIndex : ]

    classPathCount = len( classPathNames )
    if classPathCount == 0:
        print( '[I] No GameObject-based classes found in ', module, '.', sep = '' )
        print()
        continue

    print( '[I] Found ', classPathCount, ' GameObject-based class(es) in ', module, '.', sep = '' )
    for classPath in classPathNames:
        print( '[I] -', classPath )

    print( '[I] Generating type registration.' )
    typeRegSourceFile = module + 'TypeRegistration.cpp'
    typeRegFileContents = sourceFormatString0.format( FILE = typeRegSourceFile, YEAR = currentYear, MODULE = module )

    for includeEntry in includeFiles:
        typeRegFileContents += includeListingFormatString.format( INCLUDE = includeEntry )

    moduleToken = ModuleToTokenName( module )

    typeRegFileContents += sourceFormatString1.format(
        MODULE = module,
        MODULE_TOKEN = moduleToken,
        API_TOKEN_PREFIX = apiTokenPrefix )

    # Special-case handling for Engine module: package creation is performed by the GameObject type registration due to
    # dependencies, so fetch and use its result.
    if module == 'Engine':
        typeRegFileContents += sourceFormatString2Engine.format( MODULE = module )
    else:
        typeRegFileContents += sourceFormatString2Default.format( MODULE = module )

    typeRegFileContents += sourceFormatString3.format(
        MODULE = module,
        MODULE_TOKEN = moduleToken,
        API_TOKEN_PREFIX = apiTokenPrefix )

    for classPath in classPathNames:
        typeRegFileContents += typeRegLineFormatString.format( CLASS_PATH = classPath )

    typeRegFileContents += sourceFormatString4.format(
        MODULE = module,
        MODULE_TOKEN = moduleToken,
        API_TOKEN_PREFIX = apiTokenPrefix )

    for classPath in classPathNames:
        typeRegFileContents += typeUnregLineFormatString.format( CLASS_PATH = classPath )

    typeRegFileContents += sourceFormatString5.format( MODULE = module )

    typeRegSourcePath = os.path.join( sourcePath, module, typeRegSourceFile )
    bWriteFile = True
    try:
        typeRegFile = open( typeRegSourcePath, 'rt' )
    except:
        pass
    else:
        print(
            '[I] Existing source file "', typeRegSourcePath, '" found, comparing with new file contents.', sep = '' )
        existingFileContents = typeRegFile.read()
        typeRegFile.close()

        if typeRegFileContents == existingFileContents:
            print( '[I] Existing source file contents match, file will not be updated.' )
            bWriteFile = False
        else:
            print( '[I] Existing source file differs, file will be updated.' )

    if bWriteFile:
        print( '[I] Writing type registration for module "',  module, '"...', sep = '' )
        try:
            typeRegFile = open( typeRegSourcePath, 'wt' )
        except:
            print(
                '[E] Error opening "', typeRegSource, '" for writing: ', sys.exc_info()[ 1 ],
                sep = '',
                file = sys.stderr )
        else:
            typeRegFile.write( typeRegFileContents )
            typeRegFile.close()
            print( '[I] Finished writing "', typeRegSourcePath, '".', sep = '' )

    print()

print( '[I] Parsing complete.' )

sys.exit( 0 )


; HOW TO USE THIS FILE
; 1. Find autoexp.dat in your VS install (for me on VS2010 it is in 
;    C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\Packages\Debugger
; 2. Save a copy of this file in a safe place in case something goes wrong
; 3. Find [Visualizer]. Below it should be something like:
;    This section contains visualizers for STL and ATL containers
;    DO NOT MODIFY
; 4. Modify it anyways by putting the below text between the [Visualizer] and warning to not modify the text file
; 5. For more information about this undocumented but extremely useful file see:
;    http://www.virtualdub.org/blog/pivot/entry.php?id=120
; 6. This has been tested only on VS2010, unicode, x64 builds. For non unicode builds, you will need to make some
;    minor changes.

; ============================ BEGIN HELIUM MODIFICATIONS ===============================

Helium::WideString{

	preview (
		#if ($c.m_buffer.m_pBuffer == 0) (
			"<empty>"
		) #else (
			#( [$c.m_buffer.m_pBuffer, su])
		)
	)

	children (
	    #(
            [raw members]: [$c,!],
            [value]: [$c.m_buffer.m_pBuffer, su]
        )
	)
}

Helium::HashMap<*>{
	preview (
		#(
			"[",
			$c.m_size,
			"]"
		)
	)
	
	children (
		#(
            [raw members]: [$c,!],
            [size]: [$c.m_size, i],
			#array (
                expr : ($c.m_pBuckets)[$i],
                size : $c.m_bucketCount
            ) : #(
				#array (
					expr: $e.m_pBuffer[$i],
					size: $e.m_size
				)
			)
		)
	)
}

Helium::Pair<*>{
	preview (
		#( "(",
			$e.m_first,
			", ",
			$e.m_second,
			")"
		)
	)

	children (
		#(
			#(first : $c.m_first),
			#(second : $c.m_second)
		)
	)
}

Helium::Map<*>{
	preview (
		#(
			"[",
			$c.m_elements.m_size,
			"](",
			#array(
				expr: $c.m_elements.m_pBuffer[$i],
				size: $c.m_elements.m_size
			),
			")"
		)
	)
	children (
	    #(
            [raw members]: [$c,!],
            [size]: [$c.m_elements.m_size, i],
            #array (
                expr: $c.m_elements.m_pBuffer[$i],
                size: $c.m_elements.m_size
            )
        )
	)
}

Helium::DynArray<*>{
	preview (
		#(
			"[",
			$c.m_size,
			"](",
			#array(
				expr: $c.m_pBuffer[$i],
				size: $c.m_size
			),
			")"
		)
	)
	children (
	    #(
            [raw members]: [$c,!],
            [size]: [$c.m_size, i],
            #array (
                expr: $c.m_pBuffer[$i],
                size: $c.m_size
            )
        )
	)
}

; This isn't working
;Helium::GameObject{
;	preview (
;		[$c.m_instanceIndex,i]
;	)
;}

; This isn't working
;Helium::Reflect::Class{
;	preview (
;		#(
;			"Class ", [$c.m_cachedName.m_pEntry, su]
;		)
;	)
;}

; Adds a member "Ref" which is strongly typed to T
Helium::StrongPtr<*>{
	; Object="0x00..." LinkIndex=123456...
	preview (
		#(
			#if ($c.m_pProxy == 0) (
				"Null"
			) #else (
				#(
					"Ref=", *($T1*) ($c.m_pProxy->m_pObject), " ",
					"LinkIndex=", $c.m_LinkIndex
				 )
			)
		)
	)
	children (
		#(
			#(Ref : *($T1*) ($c.m_pProxy->m_pObject)),
			#(LinkIndex : $c.m_LinkIndex),
			#(Proxy: $c.m_pProxy)
		)
	)
}

; Adds a member "Ref" which is strongly typed to T
Helium::WeakPtr<*>{
	; Object="0x00..." LinkIndex=123456...
	preview (
		#(
			#if ($c.m_pProxy == 0) (
				"Null"
			) #else (
				#(
					"Ref=", *($T1*) ($c.m_pProxy->m_pObject), " ",
					"LinkIndex=", $c.m_LinkIndex
				)
			)
		)
	)
	children (
		#(
			#(Ref : *($T1*) ($c.m_pProxy->m_pObject)),
			#(LinkIndex : $c.m_LinkIndex),
			#(Proxy: $c.m_pProxy)
		)
	)
}

; Shows simply the name
Helium::NameBase<*>{
	preview (
		#(
			[$c.m_pEntry,su]
		)
	)
}

; Shows game object paths in an unfortunate backwards notation, but it's better than nothing
Helium::GameObjectPath{
	preview (
		#(
			"Path=",			
			#list(
				head: *$e.m_pEntry,
				next: pParent
			) : [$e.name.m_pEntry, su],
			" Instance=", 
			$e.m_pEntry->instanceIndex,

		)
	)
}


; ============================ END HELIUM MODIFICATIONS ===============================

